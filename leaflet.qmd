# Introduction to Leaflet

```{r, echo = FALSE, include = FALSE, message = FALSE}

source("_common.R")

```


**"Leaflet"** is one of the most popular open-source JavaScript libraries for interactive maps."
https://rstudio.github.io/leaflet/articles/leaflet.html


```{r, eval = FALSE}
install.packages("leaflet")
# to install the development version from Github, run
# devtools::install_github("rstudio/leaflet")
```


https://leafletjs.com/examples.html


## From Static to Interactive: ggplot() vs. leaflet()

In the previous sections, we relied on the power of `ggplot2`'s integration with the `sf` package
via  `ggplot() + geom_sf(..).` 

Conceptually, how you build maps in `ggplot2` translates very well to `leaflet,` though there are key differences we will discuss. 

In a nutshell, building maps in leaflets requires you to be **much more explicit** in everything you build in comparison to ggplot that handles a lot of logic automatically within its defaults. 


### Layering Logic

In `ggplot2`, you build your map by adding layers on top of one another. You might start with a base layer, add your geom_sf() polygons, and then perhaps add some points or text on top.

`Leaflet` conceptually works the same way:

* The first object you add is the "canvas" (the bottom layer, often a basemap)

* Subsequent objects (polygons, lines, points, annotations) are added on top of the previous ones

* The order of your code determines the order of the drawing.



### The Syntax Shift: Operator

The primary syntactic difference lies in *how we bind* these layers together.

* In `ggplot2`: We use the **plus sign (+)** to add layers to a plot object.

* In `leaflet`: We use the **pipe operator (%>% or |>)** to chain functions together.


**Think of the pipe in Leaflet exactly as you use it in `dplyr` for data manipulation:**

* you are passing your map object into the next function to add a new feature.


### Coordinate Reference Systems (CRS)

In the prior sections on building static maps, we stressed the importance of choosing the "correct" CRS (e.g., using an Albers Equal Area projection to ensure that counties in the north aren't visually distorted compared to those in the south). In `ggplot2`, you have total control over this projection.

**Leaflet is different.** Because Leaflet is built for web mapping (like Google Maps or OpenStreetMap), it relies on a standardized tiling system.

* **Display:** Leaflet effectively forces the map display into Web Mercator (EPSG: 3857). You generally do not change this.

* **Inputs**: Leaflet expects your data objects (i.e. your shapefiles) to be in **WGS84 (EPSG: 4326)**


While the `leaflet` package in R is smart enough to attempt to automatically re-project your sf data on the fly, mapping in leaflet will work better for you if you transform everything to WGS84 *before feeding it into the map*. 



### Color Scales and Legends are Handled Differently

#### Color Scales

In `ggplot2`, mapping a variable to color is as simple as `aes(fill = value_variable)`. `ggplot` handles the logic of converting quantitative numbers to a gradient color scale automatically, or users can utilize a function like `scale_fill_manual()` to further customize the palette used. 


`leaflet()` requires users to build color scales and mapping manually. The best way I've found to do this is to create a "palette function" that translates a domain of numbers into a range of colors.

#### Legends

Similar to color scale handling, ggplot() automatically handles the breaks, labels, and positioning of the legend for you. You can also use the behavior of adding custom `+ theme(...)` elements to tailor the text size, color, and positioning. 

leaflet() treats legends as completely independent objects. Because the map layers and the legend are separate HTML elements, they do not "talk" to each other.

* You must explicitly add the legend using `%>% addLegend(...)`.

* You have to tell the legend again which palette function and which data values to use. If you change the palette for your polygons but forget to update the legend, they will mismatch.

* The legend floats on top of the map. You can set the corner you want it placed in, but it does not draw outside of the map -- it covers and float on top of whatever is underneath it. You can use custom javascript and .css styling to customize it, but leaflet's base arguments for `addLegend()` do not natively support adjusting text size, color, etc. 




## Data Preparation: U.S. Census Data

For the next sections, we will use a subset of U.S. Census Data (ACS 5-year survey estimates) generated for Lewis and Clark County and its neighbors. We will focus on two variables: **total population** and **median household income.**

*(Note: For details on how we utilized custom functions to generate this census dataframe, see the "Custom Census Functions" page.)*


```{r}

census_df <- read.csv(file = here::here("_data/census_data/complete_census_df.csv")) %>%
  filter(
    !str_detect(NAME, "Census Tract"),
    stat_type != "denom",
    variable %in% c("B01003_001", "B19013_001")
  ) %>%
  distinct()

```


We use the `tigris` library to pull in the five county boundaries of interest
as a shapefile:

```{r}

counties <- c("Lewis and Clark", "Jefferson", "Broadwater", "Powell", "Meagher")

cnty_sf <- counties(state = "MT", cb = TRUE, progress_bar = FALSE) %>% 
  filter(NAME %in% counties) %>%
  select(GEOID)

```



Then, we can join the attributes to the geometry using the **"GEOID"** field.

```{r}

##--subset at first just for a single ACS 5-year (2018-2023) and total population

plot_df_1 <- census_df %>% filter(year == 2023, variable == "B01003_001") %>%
  mutate(
    GEOID = as.character(GEOID),
    NAME = str_remove(NAME, "County, Montana")
  )

##--join to the geometry
cnty_sf_join_1 <- cnty_sf %>%
  left_join(plot_df_1, by = "GEOID")


```



## 1. Simple Map Build


```{r, echo = FALSE}

# Static map using ggplot() + goem_sf()

ggp1 <- ggplot() +    
  geom_sf(data = cnty_sf_join_1, aes(fill = estimate)) + 
  scale_fill_viridis_c(option = "mako",direction = -1, name = "Total Population")+
  theme_void()

```



```{r, echo = FALSE}

# Interactive map using leaflet()

##-- set CRS to WGS94
cnty_sf_leaf_1 <- st_transform(cnty_sf_join_1, crs = 4326)

##-- map color scale for polygon fill
pop_pal_1 <- colorNumeric(
  palette = viridis::mako(256, direction = -1), 
  domain = cnty_sf_leaf_1$estimate
)

##-- simple leaflet() map call: 
leaf1 <- leaflet(data = cnty_sf_leaf_1) %>% 
  addTiles() %>%
  addPolygons(                          
    fillColor = ~pop_pal_1(estimate),
    weight = 1,
    fillOpacity = 1,
    color = "black"
  ) %>% 
  addLegend(
    pal = pop_pal_1,             
    values = ~estimate,          
    title = "Total Population",  
    opacity = 1,                 
    position = "topright"     
  )

```


::: {.layout-columns}

::: {.column width="40%"}



```{r, echo = FALSE}

ggp1

```



```{r, eval = FALSE}
#| code-fold: true

# Static map using ggplot() + goem_sf()

ggp1 <- ggplot() +    
  geom_sf(data = cnty_sf_join_1, aes(fill = estimate)) + 
  scale_fill_viridis_c(option = "mako",direction = -1, name = "Total Population")+
  theme_void()

```



:::

::: {.column width="40%"}



```{r, echo = FALSE}

leaf1

```


```{r, eval = FALSE}
#| code-fold: true


# Interactive map using leaflet()

##-- set CRS to WGS94
cnty_sf_leaf_1 <- st_transform(cnty_sf_join_1, crs = 4326)

##-- map color scale for polygon fill
pop_pal_1 <- colorNumeric(
  palette = viridis::mako(256, direction = -1), 
  domain = cnty_sf_leaf_1$estimate
)

##-- simple leaflet() map call: 
leaf1 <- leaflet(data = cnty_sf_leaf_1) %>% 
  addTiles() %>%
  addPolygons(                          
    fillColor = ~pop_pal_1(estimate),
    weight = 1,
    fillOpacity = 1,
    color = "black"
  ) 

```


:::

:::




## 2. Adding labels and annotations



```{r, echo = FALSE}


# Add labels to the existing static map
ggp1b <- ggp1 + 
  geom_sf_label(
    data = cnty_sf_join_1, 
    aes(label = NAME), 
    size = 3, 
    color = "black",   
    fill = "white",    
    fontface = "bold"
  )

ggp1b


```




```{r}

# need to get center points of polygons to draw static text labels
cnty_centers <- st_centroid(cnty_sf_leaf_1)

leaf1b <- leaf1 %>% 
  addLabelOnlyMarkers(
    data = cnty_centers,
    label = ~NAME,
    labelOptions = labelOptions(
      noHide = TRUE,         
      textOnly = TRUE,       
      direction = "center",  
      style = list(           
        "color" = "black",
        "font-weight" = "bold",
        "font-size" = "10px",
        "background-color" = "white",
        "padding" = "3px 5px",                          
        "border-radius" = "3px"                         
      )
    )
  )

leaf1b
```





## The power of `leaflet()`

So up until this point, we were able to create nearly identical maps using ggplot() and leaflet(), with the exception that our leaflet() map allowed us to add in a basemap, and pan and zoom around.

In terms of basic function, this is where creating static maps in ggplot() ends, and we dive into where the interactivity in leaflet really starts to shine.


### Basemaps a.k.a. "Provider Tiles"


In the first map, we used `addTiles()` that defaults to **OpenStreetMap (OSM) tiles.**

More often than not, this default is too colorful and too busy for epi-focussed maps. We want a quieter background that lets the data stand out.

The good news: there are dozens of free alternatives available. 

The most straightforward list of options comes from the built-in **providers** list in R. You can see all available names by running `names(providers)` in your console, or by visiting the [Leaflet Providers Preview site](https://leaflet-extras.github.io/leaflet-providers/preview/).


When building the map, `addTiles()` becomes: `addProviderTiles(...)`


**Important note here:** many map providers require you to register and get an API key or token that you need to bring in for it to work. 

Providers like "OpenStreetMap", "CartoDB," and "Esri" do not require an API key, so will work seamlessly out-of-the-box without needing to take any additional steps. 


### Here are my "go-to" basemaps:

For the most "bare-bones" and simple look: 

* **providers$Esri.WorldGrayCanvas**: A very minimalist, grayscale background

* **providers$CartoDB.Positron**: Very similar to Esri's Gray Canvas, but with a tad more detail added like major roadways and more detailed area labels for cities and towns. 

  * * **providers$CartoDB.PositronNoLabels**: same as above but without labels
  
  * * **providers$CartoDB.DarkMatter**: dark mode
  
  * * **providers$CartoDB.DarkMatterNoLabels**: dark mode no labels


If references like roads or geogrpahic features are important:   

* **providers$Esri.OceanBasemap**: basic detail of topography and geographic features with colors for forested areas, waterbodies, major roads and boundaries. 

* **providers$Esri.WorlTerrain**: very simple shaded relief of topography
  
* **providers$CartoDB.Voyager**: if roads and major geographic markers are still helpful, but still less colorful and busy as the OpenStreetMap

  * **providers$CartoDB.VoyagerNoLabels**: same-same, no labels
  
  
  

```{r}

##-- simple leaflet() map call: 
leaf_base <- leaflet(data = cnty_sf_leaf_1) %>% 
  addPolygons(                          
    fillColor = ~pop_pal_1(estimate),
    weight = 1,
    fillOpacity = 1,
    color = "black"
  ) 

# Add the Esri Grey Canvas basemap
leaf_grey <- leaf_base %>%
  addProviderTiles(providers$Esri.WorldGrayCanvas)

leaf_grey

```


```{r}




```






As we learned earlier, choropleth maps are often not the best choice. So we can use varying point sizes instead by abstracting the polygon's central points. 











