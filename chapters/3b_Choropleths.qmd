# Choropleth Maps

```{r, echo = FALSE}

source("_common.R")

```


**Choropleth Maps**
A choropleth map plots the raw geographic topology and colors each geographic entity according to the value of the variable being visualized. However, based on color alone, it is difficult to make more detailed quantitative comparisons.

**Disadvantages of Choropleth Maps**

  - Only visualize one variable and one value per geogrpahic entity. What if we want to look at how rates of X have changed over time for each state, or compare a raw vs. an adjusted rate?
  
  - Only use color for visual encoding: Color is one of the least effective ways to visually encode information (people have a harder time interpreting color differences, and therefore make judgements, accurately). 
  
  - Favor large geographic entities: A well-known issue with choropleth maps is that they visually favor geographically large regions over small regions.


There are many ways to deal with this problem through other types of maps.

:::{.callout-note}

## Obtain API "key"
**Quick Note:** to obtain census API data, you need to first acquire a "key."
Visit this website to get your access key: https://api.census.gov/data/key_signup.html

And then run this code with the key you receive: 
`census_api_key("<your key here>")`
:::

```{r, results = "hide", message = FALSE, warning = FALSE}
#| code-fold: true
#| code-summary: "Show the code"

library(sf)
library(tigris)
library(ggplot2)
library(cowplot)
library(gridExtra)
library(classInt)
library(dplyr)

# Brought in some census data using tidycensus

# income <- get_acs(
  #geography = "tract", 
  #variables = "B19013_001",
  #state = "Montana", 
  #year = 2020,
  #geometry = TRUE)

# Convert to sf object
## income <- st_as_sf(income)
## st_write(income, "income.shp")  


# Bring in shapefile
income <- st_read(here::here("data/shapefiles/income", "income.shp"))


# Remove tracts without income data
income <- income[complete.cases(st_drop_geometry(income)), ]

```


Let's start by just plotting the census tracts

```{r}

ggplot(income)+
  geom_sf()


```


Fantastic. This is just plotting the geometry of the shapefile (polygons of census tracts in Montana). Pretty boring map, though. 


We can dive a bit further, and use a choropleth map to visualize median household income by tract.
We will use the `fill = <variable>` call to tell ggplot to fill in the geometry by that variable. 

```{r}

ggplot(income)+
  geom_sf(aes(fill = estimate))

```


Well, this is not as boring as the first map. However, if being able to visually differentiate and compare median income among different counties was important, this would be a bit hard to do here.

Income data might be one case where we may consider a **divergent** color scale. This can be a good option for scenarios where you'd like to emphasize both extremes of a spectrum of values. In this case, it might be interesting to have the lowest and the highest earning census tracts stick out. 

**Just a quick trick here:** If you're going to be creating multiple maps with the same theme, 
you can make a list of those theme arguments and then apply the `plot_theme` object you created to each map, just by adding a ` + plot_theme$theme ` , instead of having to type or copy/paste these out a million times. Another huge benefit is that this allows you to make adjustments to only one theme call, instead of having to go back and adjust for each individual plot. 


```{r}
#| code-fold: true
#| code-summary: "Show the code"

plot_theme <- 
      
      list(
      theme = theme(legend.position = "none", 
              axis.title = element_blank(),   
              axis.text = element_blank(),    
              axis.ticks = element_blank(), 
              axis.line = element_blank()))
      
```




```{r}
#| code-fold: true
#| code-summary: "Show the code"

noclass <- ggplot(income) +
  geom_sf(aes(fill = estimate)) + 
  scale_fill_distiller(palette="RdYlGn", 
                           direction = 1) + 
  ggtitle("No Classification") + 
  theme_classic()+
  plot_theme$theme

noclass

```

I think this map does a better job of drawing your eyes to the wealthiest and the poorest tracts, in terms of median household income. We also added a `theme_void()` argument to get rid of the coordinate grid in the background. 


## Classification and Binning 

How we decide to classify the data we are displaying in a choropleth map can **drastically** change the message and the story that is conveyed.

How we classify and portray the variable of interest is therefore subject to the map makers decision. 

:::{.callout-warning}
Use caution and thoughtfulness around this decision!
:::


So...

![Classifying Data](..\images/classify_1.png){.lightbox}

---------

**Common classification methods**

  - **Equal Interval**
    - Break spacing is constant, and will occur every specified 'X' units.
    - There will be **different counts of observations** within each group. In the photo above, the breaks are evenly spread out, but we can see that many more observations will be included in the first couple breaks than the last two. 
    - A good method to use if you wanted to highlight the outliers within a distribution of data. 
    
  - **Quantile (equal count)**
    - In a quantile classification, we break up the distribution by "nth" percentile. 
    - Unlike the equal interval, there will be **the same number of observations** that fall into each percentile break. 
    - The spacing of the breaks are obviously not even. Instead, they are broken up into, for example, every 20th, 10th, etc., percentile. 
    
  - **Natural breaks (Jenks)**
    - This is an **optimization** method
    - Groups are aranged so that there is **less variation in each class**
    
  - **Standard Deviation**
    - This method starts by first calculating the **mean** of your observations. 
    - Then, each standard deviation from that mean becomes the "break" or class
    - This might result in a different number of classifications that other methods. 
    
  - **Pretty Breaks**
    - The main defining feature of this method is that it creates **rounded numbers** for your breaks. 
    - This method might be picky about the number of classes, because it needs to be able to group your data into these "pretty" breaks. 
    
  - **Unclassified**
    - **USE** if you want to let the data speak for itself, without any manipulation. Or, if you want to let subtle differences remain as such through color. 
    - Can reduce subjective bias that may be introduced through classification
    - **DO NOT USE** if you want to be able to carefully compare one location to another, or
    - get precise numbers from reading your map

    
### Create the breaks in R for your maps: {.unnumbered}

::: {layout-ncol=2}

![create breaks](..\images\breaks1.png){.lightbox}


![create breaks](..\images\breaks2.png){.lightbox}


:::

----------

### Jenks Breaks {.unnumbered}

```{r}
#| code-fold: true
#| code-summary: "Show the code"

library(sf)
library(tigris)
library(ggplot2)
library(cowplot)
library(gridExtra)
library(classInt)

# Use classIntervals to create the "jenks" breaks: 
breaksJ = classIntervals(income$estimate, n = 5, style = "jenks")

# Format the break points if needed before using cut() **optional**
formatted_breaksJ <- format(breaksJ$brks, scientific = FALSE, big.mark = ",")

income$breaksJ <- cut(income$estimate, 
                       breaks = breaksJ$brks, 
                       include.lowest = TRUE, 
                       labels = paste("(", head(formatted_breaksJ, -1), 
                                       " - ", tail(formatted_breaksJ, -1), ")"))

jenks <- ggplot(income) +
  geom_sf(aes(fill = breaksJ)) +
  scale_fill_manual(values = c("#d73027", "#fdae61", "#ffffbf", "#a6d96a", "#1a9641")) +
  ggtitle("Jenks")+
  theme_classic()+
  plot_theme$theme

jenks
  
```



---------


### Quantile Breaks {.unnumbered}

```{r}
#| code-fold: true
#| code-summary: "Show the code"

# Use classIntervals to create the "quantile" breaks: 
breaksQ = classIntervals(income$estimate, n = 5, style = "quantile")

# Format the break points if needed before using cut() **optional**
formatted_breaksQ <- format(breaksQ$brks, scientific = FALSE, big.mark = ",")

income$breaksQ <- cut(income$estimate, 
                       breaks = breaksQ$brks, 
                       include.lowest = TRUE, 
                       labels = paste("(", head(formatted_breaksQ, -1), 
                                       " - ", tail(formatted_breaksQ, -1), ")"))

quant <- ggplot(income) +
  geom_sf(aes(fill = breaksQ)) +
  scale_fill_manual(values = c("#d73027", "#fdae61", "#ffffbf", "#a6d96a", "#1a9641")) +
  ggtitle("Quantile")+
  theme_classic()+
  plot_theme$theme

quant

```


----------

### Equal Interval Breaks {.unnumbered}

```{r}
#| code-fold: true
#| code-summary: "Show the code"

# Use classIntervals to create the "equal interval" breaks: 
breaksEQ = classIntervals(income$estimate, n = 5, style = "equal")

# Format the break points if needed before using cut() **optional**
formatted_breaksEQ <- format(breaksEQ$brks, scientific = FALSE, big.mark = ",")

income$breaksEQ <- cut(income$estimate, 
                       breaks = breaksEQ$brks, 
                       include.lowest = TRUE, 
                       labels = paste("(", head(formatted_breaksEQ, -1), 
                                       " - ", tail(formatted_breaksEQ, -1), ")"))

EQ <- ggplot(income) +
  geom_sf(aes(fill = breaksEQ)) +
  scale_fill_manual(values = c("#d73027", "#fdae61", "#ffffbf", "#a6d96a", "#1a9641")) +
  ggtitle("Equal Interval")+
  theme_classic()+
  plot_theme$theme

EQ

```


---------

### Standard Deviation Breaks {.unnumbered}

```{r}
#| code-fold: true
#| code-summary: "Show the code"

# Use classIntervals to create the "standard deviation" breaks: 
breaksSD = classIntervals(income$estimate,  style = "sd")

# Format the break points if needed before using cut() **optional**
formatted_breaksSD <- format(breaksSD$brks, scientific = FALSE, big.mark = ",")

income$breaksSD <- cut(income$estimate, 
                       breaks = breaksSD$brks, 
                       include.lowest = TRUE, 
                       labels = paste("(", head(formatted_breaksSD, -1), 
                                      " - ", tail(formatted_breaksSD, -1), ")"))

```


As discussed earlier, the **standard deviation** method likely will result in a different number of classifications than before. We do not specify the number of "breaks" or "classes" ourselves. Rather, the mean is calculated and the number of classifications of standard deviations from that mean will depend on the distribution of our data. 

Let's take a peak so we understand how much our palette needs to either grow or shrink: 

```{r}

library(dplyr)
glimpse(income$breaksSD)

```


Ok, so this tells us that it generated 8 classes. With our divergent color palette here, we will make sure the palette is relatively centered by adding one more color in each category:


```{r}

SD <- ggplot(income) +
  geom_sf(aes(fill = breaksSD)) +
  scale_fill_manual(values = c("#d73027", "#f46d43", "#fdae61", 
                               "#fee08b", "#ffffbf",  
                               "#a6d96a", "#1a9641","#006837")) +  
  ggtitle("Standard Deviation")+
  theme_classic()+
  plot_theme$theme

SD

```

### Compare Classifications Histograms {.unnumbered}

**Let's take a look and see how each classification is applied to the distribution of median houshold income by census tract:**


```{r, echo = FALSE, fig.height = 10, fig.width = 10, message = FALSE}
#| code-fold: true
#| code-summary: "Show the code"

j_hist <- ggplot() + 
              geom_histogram(data = income, 
                 aes(x = estimate, 
                     fill = breaksJ), 
                 color = "black") + 
                scale_fill_manual(values = c("#d7191c", "#fdae61", "#ffffbf", 
                                 "#a6d96a", "#1a9641")) +
  ggtitle("Jenks") +
  theme_classic()+
  plot_theme$theme

q_hist <- ggplot() + 
              geom_histogram(data = income, 
                 aes(x = estimate, 
                     fill = breaksQ), 
                 color = "black") + 
                scale_fill_manual(values = c("#d7191c", "#fdae61", "#ffffbf", 
                                 "#a6d96a", "#1a9641")) + 
  ggtitle("Quantile") +
  theme_classic()+
  plot_theme$theme


eq_hist <- ggplot() + 
              geom_histogram(data = income, 
                 aes(x = estimate, 
                     fill = breaksEQ), 
                 color = "black") + 
                scale_fill_manual(values = c("#d7191c", "#fdae61", "#ffffbf", 
                                 "#a6d96a", "#1a9641")) + 
  ggtitle("Equal Interval") +
  theme_classic() +
  plot_theme$theme

sd_hist <- ggplot() + 
              geom_histogram(data = income, 
                 aes(x = estimate, 
                     fill = breaksSD), 
                 color = "black") + 
                scale_fill_manual(values = c("#d73027", "#f46d43", "#fdae61", 
                               "#fee08b", "#ffffbf",  
                               "#a6d96a", "#1a9641","#006837")) +
  ggtitle("Standard Deviation") +
  theme_classic()+
  plot_theme$theme


```


```{r, echo = FALSE, fig.height = 10, fig.width = 10, message = FALSE}

plot_grid(j_hist, q_hist, 
          eq_hist, sd_hist,
          ncol = 2, 
          rel_widths = c(1, 1), 
          align = "hv")
```

----------

### Compare Classifications Histograms {.unnumbered}

* **How we decide to classify the data we are displaying in a choropleth map can drastically change the message and the story that is conveyed.**

* **How we classify and portray the variable of interest is subject to the map maker's decision.**

* **Use caution and thoughtfulness!**


```{r, echo = FALSE, fig.height = 14, fig.width = 10}


plot_grid(jenks, quant, 
          EQ, SD,
          noclass,
          ncol = 2, 
          align = "hv")


```







