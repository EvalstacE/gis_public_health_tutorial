# Custom Functions

## `apply_custom_theme` {.unnumbered}

The only input needed is:

-   `plot` = name of ggplot object

**Example Use:**

```{r, eval = FALSE}

# custom theme applied to ggplot object saved as "depression_plot : 

depression_plot <- apply_custom_theme(depression_plot)


```

### `apply_custom_theme` code {.unnumbered}

```{r, eval = FALSE}
#| code-fold: true
#| code-summary: "Show the code"

plot_theme <- list(
  theme = theme( 
    legend.position = "top",
    legend.justification = "left",
    legend.title.position = "top",
    plot.title = element_text(color = "white", face = "bold", size = 22),
    plot.subtitle = element_text(color = "white", size = 16, margin = margin(b=15)),
    plot.caption = element_markdown(color = "white", size = 8, hjust = 0, face = "italic"),
    legend.title = element_text(color = "white", size = 14),
    legend.text = element_text(color = "white", size = 12),
    legend.key.height = unit(0.75, "cm"),
    legend.key.width = unit(2, "cm"),
    plot.margin = margin(t= 15, b = 15)))

# Scale bar 
scale <- list(annotation_scale = 
  annotation_scale(
  location = "br",    
  width_hint = 0.25,    
  pad_x = unit(0.2, "cm"),  
  pad_y = unit(0.2, "cm"),  
  text_col = "white",  
  line_col = "#021628", 
  bar_cols = c("white", "grey")))

# Caption to include for all maps: 

caption_text <- paste(
"**Map created by:** Val Stacey", ";", 
"**Created on:**", format(Sys.Date(), "%m/%d/%Y"), ";",
"**Data Sources:** CDC PLACES: BRFSS, US Census Bureau", ";" , 
"**Map Projection:** Albers Equal Area, EPSG:32100 <br>  ", "  
**Map created in R (R Core Team (2024))** using ggplot2, sf, 
  and other spatial analysis packages", ";", 
"**R version:** 4.4.0 (2024-04-24 ucrt)")


# Function to add theme and caption to plots: 

apply_custom_theme <- function(plot) {
  plot + labs(caption = caption_text) + scale$annotation_scale + plot_theme$theme
}

```

## `classify_ntl_deviation` {.unnumbered}

The custom function , `classify_ntl_deviation`, is designed to categorize values base on how much they deviate from the national median value. It provides two options for doing this:

-   **Standard Deviation** (`method = "sd"`)

-   Compares `value` to a `ntl_med` (given a particular measure) using the national standard deviation for that measure.

-   **Percentage** (`method = "percentage"`)

-   Uses a fixed threshold of +/- 1.5% or +/- 2%

-   This use is most helpful when the national standard deviation for a given measure is large

**Key Calls and Options:**

-   `value`: the column name that holds the data values to be compared to national medians
-   `ntl_med`: the national median value of a measure
-   `method:` Determines whether the classification is based on standard deviation (`method = "sd"`) or absolute percentage deviations (`method = "percentage"`).
-   `ntl_sd:` the national standard deviation for the measure
-   only specify when `method = "sd"`

**Example Use:**

```{r, eval = FALSE}

depression <- depression %>%
  mutate(percent_diff = Data_Value - national_median, 
         sd_cat = classify_ntl_deviation(
                    Data_Value, ntl_med = first(national_median),
                    ntl_sd = fist(national_sd)),
         percent_cat = classify_ntl_deviation(
           Data_Value, ntl_med = 25.05, method = "percentage"))

```

### `classify_ntl_deviation` code {.unnumbered}

```{r, eval = FALSE}
#| code-fold: true
#| code-summary: "Show the code"

classify_ntl_deviation <- function(value, ntl_med, ntl_sd = NULL, method = "sd") {
  
  if (method == "percentage") {
    case_when(
    value >= (ntl_med - 1.5) & value <= (ntl_med + 1.5) ~ 
      "Near national median",
    value > (ntl_med + 1.5) & value <= (ntl_med + 2) ~ 
      "Slightly above national median",
    value < (ntl_med - 1.5) & value >= (ntl_med - 2) ~ 
      "Slightly below national median",
    value > (ntl_med + 2) ~ "Above national median",
    value < (ntl_med - 2) ~ "Below national median",
    TRUE ~ NA_character_)
    
  } else {  
    case_when(
    value >= (ntl_med - ntl_sd) & value <= (ntl_med + ntl_sd) ~ 
      "Near national median",
    value > (ntl_med + ntl_sd) & value <= (ntl_med + 2 * ntl_sd) ~ 
      "Slightly above national median",
    value < (ntl_med - ntl_sd) & value >= (ntl_med - 2 * ntl_sd) ~ 
      "Slightly below national median",
    value > (ntl_med + 2 * ntl_sd) ~ "Above national median",
    value < (ntl_med - 2 * ntl_sd) ~ "Below national median",
      TRUE ~ NA_character_)
  }
}


```

## `generate_legend_labels` {.unnumbered}

Inputs needed:

-   `ntl_med` = national median value
-   `method` = defaults to "sd", other option is "percentage"
-   `ntl_sd` = national standard deviation (not needed if method = "percentage")

To call on `ntl_med` and `ntl_sd`, we can utilize `first(<dataframe$national_median>)` and `first(<dataframe$national_sd>)`, because in our dataframe, there is a single median and standard deviation value duplicated for all rows given each measure. This is particularly helpful for when this function gets incorporated into our overall map-making function.

**Example Use:**

```{r, eval = FALSE}

# Using national standard deviation as measure: 

legend_labels_depression_sd <- 
  generate_legend_labels(ntl_med = first(counties_depression$national_median), 
                         ntl_sd = first(counties_depression$national_sd))

# Using percentage points as measure: 

legend_labels_binge_p <- 
  generate_legend_labels(ntl_med = first(counties_depression$national_median), 
                         method = "percentage")

```

### `generate_legend_labels` code {.unnumbered}

```{r, eval = FALSE}
#| code-fold: true
#| code-summary: "Show the code"

generate_legend_labels <- function(ntl_med, ntl_sd = NULL, method = "sd") {
  
  if (method == "percentage") {
    below_2_high <- ntl_med - 2
    below_1_high <- ntl_med - 1.5
    below_1_low  <- ntl_med - 2
    near_high    <- ntl_med + 1.5
    near_low     <- ntl_med - 1.5
    above_1_low  <- ntl_med + 1.5
    above_1_high <- ntl_med + 2
    above_2_low  <- ntl_med + 2
    
  } else {  # Default is "sd" method
    below_2_high <- ntl_med - 2 * ntl_sd 
    below_1_high <- ntl_med - ntl_sd      
    below_1_low  <- ntl_med - 2 * ntl_sd  
    near_high    <- ntl_med + ntl_sd
    near_low     <- ntl_med - ntl_sd
    above_1_low  <- ntl_med + ntl_sd
    above_1_high <- ntl_med + 2 * ntl_sd
    above_2_low  <- ntl_med + 2 * ntl_sd
  }

labels <- setNames(c(
  
  paste0("Near national median\n(", 
         round(near_low, 2), " - ", 
         round(near_high, 2), "%)"),

  paste0("Slightly below national median\n(", 
         round(below_2_high, 2), " - ",
         round(below_1_high, 2), "%)"),
  
  paste0("Slightly above national median\n(", 
         round(above_1_low, 2), " - ", 
         round(above_1_high, 2), "%)"),
  
  paste0("Above national median\n(> ", 
         round(above_2_low, 2), "%)"),
  
  paste0("Below national median\n(< ", 
         round(below_2_high, 2), "%)")),
  
c("Near national median", "Slightly below national median", 
  "Slightly above national median", "Above national median", 
  "Below national median"))

  return(labels)
}


```

## `create_PLACES_maps` {.unnumbered}

There's a lot going on in this code, but it is essentially just a combination of all the other functions we created that allows us to iterate through any measure we would like to within the PLACES dataset. Its final outputs are a series of maps.

### `create_PLACES_maps` code {.unnumbered}

```{r, eval = FALSE}
#| code-fold: true
#| code-summary: "Show the code"

create_PLACES_maps <- function(measure, data, counties, boundary, theme_function) {
  
###########################################  
# --- STEP 1: FILTER AND PROCESS DATA --- #
###########################################
  
measure_data <- data %>%
  
# filters for the measure you specify
filter(Measure == measure) %>%
  
# select to remove unnecessary columns
select(Year, LocationName, Measure, Data_Value_Type, Data_Value, 
       Low_Confidence_Limit, High_Confidence_Limit, TotalPopulation, 
       TotalPop18plus, national_median, national_sd) %>%

mutate(
# calculate percent difference between each county value and the national median
percent_diff = Data_Value - national_median,

# classify values using our function: `classify_ntl_deviation`
# sd_cat = applies (method = "sd")
sd_cat = classify_ntl_deviation(Data_Value, ntl_med = first(national_median), 
                                            ntl_sd = first(national_sd)),

# percent_cat = applies (method = "percentage")       
percent_cat = classify_ntl_deviation(Data_Value, ntl_med = first(national_median), 
                                     method = "percentage")) %>%
  
# set factor levels so things plot in logical order:
mutate(
sd_cat = factor(sd_cat, 
  levels = c("Below national median", "Slightly below national median", 
             "Near national median", "Slightly above national median",
             "Above national median")),

percent_cat = factor(percent_cat,
  levels = c("Below national median", "Slightly below national median", 
             "Near national median", "Slightly above national median",
             "Above national median")))

#########################################################
# --- STEP 2: CLASSIFY USING NATURAL BREAKS (JENKS) --- #
#########################################################

# set up jenks breaks 
breaksJ <- classIntervals(measure_data$Data_Value, n = 5, style = "jenks")

# clean up so labels are neat
formatted_breaksJ <- format(breaksJ$brks, scientific = FALSE, big.mark = ",")

# apply jenks breaks to data
measure_data$breaksJ <- cut(measure_data$Data_Value, 
                            breaks = breaksJ$brks, 
                            include.lowest = TRUE, 
                            labels = paste("(", head(formatted_breaksJ, -1), 
                                             " - ", tail(formatted_breaksJ, -1), ")"))

####################################################  
# --- STEP 3: JOIN DATA TO GEOMETRY (COUNTIES) --- #
####################################################

counties_measure <- counties %>% 
  left_join(measure_data, by = c("NAME" = "LocationName"))

##########################################  
# --- STEP 4: GENERATE LEGEND LABELS --- #
##########################################

legend_labels_sd <- generate_legend_labels(
                    ntl_med = first(measure_data$national_median), 
                    ntl_sd = first(measure_data$national_sd))

legend_labels_p <- generate_legend_labels(
                   ntl_med = first(measure_data$national_median), 
                   method = "percentage")

######################################
# --- STEP 5: GENERATE JENKS MAP --- #
######################################

jenks_plot <- ggplot() + 
  as_reference(geom_sf(data = boundary, color = "white", fill = NA, linewidth = 2), 
      id = "boundary") + with_blur("boundary", sigma = 10) +  
  geom_sf(data = boundary, color = "#1a3b58", fill = NA) +
  geom_sf(data = counties_measure, aes(fill = breaksJ, color = breaksJ)) +  
  scale_fill_manual(values = c("#021628","#213242","#4d5d6c","#f47d59","#ff3131")) +
  scale_color_manual(values = c("#213242","#021628","#021628","#021628","#021628")) +
  labs(title = paste(measure, "- Jenks Classification"),
        subtitle = "(Age-adjusted prevalence by county in Montana)",
        fill = "Prevalence") +
  guides(fill = guide_legend(nrow = 2), color = "none") + 
  theme_void() + 
  theme(legend.key.spacing = unit(0.5, "cm"))

# --- Apply custom theme --- #
  jenks_plot <- theme_function(jenks_plot)

###################################################  
# --- STEP 6: NATIONAL MEDIAN COMPARISON MAPS --- #
###################################################

# --- Utilizing method = "sd" --- #
  
national_median_plot <- ggplot() +
  as_reference(
    geom_sf(data = boundary, color = "white", fill = NA, linewidth = 2), 
    id = "boundary") + with_blur("boundary", sigma = 10) +  
    geom_sf(data = boundary, color = "#1a3b58", fill = NA) +
    geom_sf(data = counties_measure, aes(fill = percent_cat, color = percent_cat)) +  
    scale_fill_manual(values = c("#021628","#213242","#4d5d6c","#f47d59","#ff3131"), 
                      labels = legend_labels_p) +
    scale_color_manual(values = c("#213242","#021628","#021628","#021628", "#021628")) +
    labs(title = paste(measure, "- Comparison to US Median"),
         subtitle = "(Age-adjusted prevalence by county in Montana)",
         fill = "Relative Prevalence") +
    guides(fill = guide_legend(nrow = 2), color = "none") + 
    theme_void() + 
    theme(legend.key.spacing = unit(0.5, "cm"))

# Apply custom theme 
national_median_plot <- theme_function(national_median_plot)

############################################  
# --- Utilizing method = "percentage " --- #

national_median_plot_sd <- ggplot() +
  as_reference(geom_sf(data = boundary, color = "white", fill = NA, linewidth = 2), 
    id = "boundary") + with_blur("boundary", sigma = 10) +  
    geom_sf(data = boundary, color = "#1a3b58", fill = NA) +
    geom_sf(data = counties_measure, aes(fill = sd_cat, color = sd_cat)) +  
    scale_fill_manual(values = c("#021628","#213242","#4d5d6c","#f47d59","#ff3131"), 
                      labels = legend_labels_sd) +
    scale_color_manual(values = c("#213242","#021628","#021628","#021628", "#021628")) +
    labs(title = paste(measure, "- Comparison to US Median"),
         subtitle = "(Age-adjusted prevalence by county in Montana)",
         fill = "Relative Prevalence") +
    guides(fill = guide_legend(nrow = 2), color = "none") + 
    theme_void() + 
    theme(legend.key.spacing = unit(0.5, "cm"))

# Apply custom theme 
  national_median_plot_sd <- theme_function(national_median_plot_sd)
  
###############################################
# --- FINAL STEP: EXPORTS PLOTS TO A LIST --- #
###############################################
  
return(list(jenks_plot = jenks_plot, 
            national_median_plot = national_median_plot,
            national_median_plot_sd = national_median_plot_sd))
}

```
